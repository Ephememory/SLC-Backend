@page "/"

<PageTitle>Index</PageTitle>

<div class="text-center">
    <h1 class="display-1" style="color: white; font-weight: 500;">Steam Library Comparer</h1>
    <div style="padding: 2%;"></div>
    <div class="flex-nowrap">
        <h2 class="display-5" style="color: white; font-weight: 200;">Enter SteamId list:</h2>
        <form id="list-form" class="text-box" type="text" @onsubmit=SubmitForm >
			<input id="steam-id-list-input" style="width: 100%; height:100%;" >
        </form>
        <div style="padding: 1%;"></div>
    </div>
</div>

@code {

	private void SubmitForm(EventArgs data)
	{
		Program.Log(data);
	}

	public async Task DoGroupLookup(List<ulong> steamids)
	{
		// Fetch their profiles.
		var summariesResponse = await Program.steamInterface.GetPlayerSummariesAsync(steamids);

		var summaries = summariesResponse.Data;

		var users = new List<UserGameLibrary>();
		foreach (var player in summaries)
		{
			// includeAppInfo: true to get stuff like the names of the games. Yes that isn't included by default.
			// We might have to also just make another service api request
			// for each game's app id to fetch info for showing a pretty display for the front-end.
			// Maybe we can do all that on the front-end, just send app ids from here.
			// E.g. displaying the game logo/store page thumbnail.

			var response = await Program.playerService.GetOwnedGamesAsync(player.SteamId, includeAppInfo: true, includeFreeGames: false);
			users.Add(new UserGameLibrary(player, response.Data.OwnedGames));
		}

		var gamesInCommon = GetGamesInCommon(users);
		foreach (var game in gamesInCommon)
		{
			Program.Log($"AppId: {game.Appid}");
			foreach (var value in game.Owners)
			{
				Program.Log($"owned by: {value} ");
			}
		}
	}

	public IEnumerable<GameWithOwners> GetGamesInCommon(IEnumerable<UserGameLibrary> users)
	{
		// TODO: Error handle, nullable return.
		// Web-related stuff always makes me wish C# had multiple returns like Go, for easier error handling.

		var gameOwnerDict = new Dictionary<uint, List<ulong>>();
		foreach (var user in users)
		{
			Program.Log($"Processing user --- SteamId: {user.Player.SteamId} NickName: {user.Player.Nickname}.");
			Program.Log($"Library size: {user.Library.Count()} games.");

			foreach (var game in user.Library)
			{
				if (gameOwnerDict.ContainsKey(game.AppId))
					gameOwnerDict[game.AppId].Add(user.Player.SteamId);
				else
					gameOwnerDict.Add(game.AppId, new List<ulong>() { user.Player.SteamId });
			}
		}

		Program.Log($"Collective virtual library size (all users combined): {gameOwnerDict.Count()} games.");

		// Process the dictionary, make a list that only includes the games owned by multiple users.
		var processedOwners = new List<GameWithOwners>();
		foreach (KeyValuePair<uint, List<ulong>> kvp in gameOwnerDict)
		{
			// The game does not have multiple owners.
			if (kvp.Value.Count <= 1)
				continue;

			processedOwners.Add(new GameWithOwners(kvp.Key, kvp.Value));
		}

		return processedOwners;
	}
}